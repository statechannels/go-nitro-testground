package chain

import (
	"context"
	"io"
	"log"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/statechannels/go-nitro-testground/utils"
	"github.com/statechannels/go-nitro/client/engine/chainservice"
	NitroAdjudicator "github.com/statechannels/go-nitro/client/engine/chainservice/adjudicator"
	chainutils "github.com/statechannels/go-nitro/client/engine/chainservice/utils"
	"github.com/statechannels/go-nitro/types"
	"github.com/testground/sdk-go/sync"
)

// NewHyperspaceChainService creates a new chain service for the Hyperspace testnet
func NewHyperspaceChainService(ctx context.Context, seq int64, naAddress types.Address, logDestination io.Writer) chainservice.ChainService {

	client, err := ethclient.Dial("https://api.hyperspace.node.glif.io/rpc/v0")
	if err != nil {
		log.Fatal(err)
	}

	// TODO: Eventually we should generate accounts using a HD wallet path used by the hyperspace burner wallet ( "m/44'/1'/0'/0")
	// However the addresses we generate from hd wallet seem to differ from the ones generated by the glif wallet
	// For now we just use the same HD wallet path as hardhat, and manually fund the addresses
	txSubmitter, err := bind.NewKeyedTransactorWithChainID(GetHyperspaceFundedPrivateKey(uint(seq)), big.NewInt(3141))
	if err != nil {
		log.Fatal(err)
	}

	na, err := NitroAdjudicator.NewNitroAdjudicator(naAddress, client)
	if err != nil {
		log.Fatal(err)
	}

	cs, err := chainservice.NewEthChainService(client, na, naAddress, common.Address{}, common.Address{}, txSubmitter, logDestination)
	if err != nil {
		log.Fatal(err)
	}
	return cs
}

func NewChainService(ctx context.Context, seq int64, logDestination io.Writer, syncClient sync.Client, instances int) chainservice.ChainService {
	client, err := ethclient.Dial("ws://chain:8545/")
	if err != nil {
		log.Fatal(err)
	}

	txSubmitter, err := bind.NewKeyedTransactorWithChainID(GetHardhatFundedPrivateKey(uint(seq)), big.NewInt(1337))
	if err != nil {
		log.Fatal(err)
	}
	txSubmitter.GasLimit = uint64(30_000_000) // in units

	gasPrice, err := client.SuggestGasPrice(context.Background())
	if err != nil {
		log.Fatal(err)
	}
	txSubmitter.GasPrice = gasPrice

	var naAddress types.Address
	// One testground instance attempts to deploy NitroAdjudicator
	if seq == 1 {
		naAddress, err = chainutils.DeployAdjudicator(ctx, client, txSubmitter)
		if err != nil {
			log.Fatal(err)
		}
		utils.SendAdjudicatorAddress(context.Background(), syncClient, naAddress)
	} else {
		naAddress = utils.WaitForAdjudicatorAddress(context.Background(), syncClient, instances)
	}

	na, err := NitroAdjudicator.NewNitroAdjudicator(naAddress, client)
	if err != nil {
		log.Fatal(err)
	}

	cs, err := chainservice.NewEthChainService(client, na, naAddress, common.Address{}, common.Address{}, txSubmitter, logDestination)
	if err != nil {
		log.Fatal(err)
	}
	return cs
}
